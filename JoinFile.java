/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
package org.apache.beam.gcp;

//import com.google.api.services.bigquery.model.TableRow;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.io.TextIO;
//import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO;
import org.apache.beam.sdk.options.Description;
import org.apache.beam.sdk.options.PipelineOptions;
import org.apache.beam.sdk.options.PipelineOptionsFactory;
import org.apache.beam.sdk.options.Validation;
import org.apache.beam.sdk.transforms.DoFn;
import org.apache.beam.sdk.transforms.ParDo;
import org.apache.beam.sdk.transforms.join.CoGbkResult;
import org.apache.beam.sdk.transforms.join.CoGroupByKey;
import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;
import org.apache.beam.sdk.values.KV;
import org.apache.beam.sdk.values.PCollection;
import org.apache.beam.sdk.values.TupleTag;

/**
* This example shows how to do a join on two collections.
* It uses a sample of the GDELT 'world event' data (http://goo.gl/OB6oin), joining the event
* 'action' country code against a table that maps country codes to country names.
*
* <p>Concepts: Join operation; multiple input sources.
*
* <p>To execute this pipeline locally, specify a local output file or output prefix on GCS:
* <pre>{@code
*   --output=[YOUR_LOCAL_FILE | gs://YOUR_OUTPUT_PREFIX]
* }</pre>
*
* <p>To change the runner, specify:
* <pre>{@code
*   --runner=YOUR_SELECTED_RUNNER
* }
* </pre>
* See examples/java/README.md for instructions about how to configure different runners.
*/
public class JoinFile {

  // A 1000-row sample of the GDELT data here: gdelt-bq:full.events.
  private static final String DEVICE_TABLE =
    "gs://bespin-bigtable-apachebeam/test/A*.txt";
    // A table that maps country codes to country names.
  private static final String CONTACT_TABLE =
    "gs://bespin-bigtable-apachebeam/test/b.csv";

  private static final int MAX_LINES = 15;

  private static int sequence_key = 1;


/**
 * Join two collections, using country code as the key.
 */
static PCollection<String> joinEvents(PCollection<String> deviceTable,
    PCollection<String> contactTable) throws Exception {

  final TupleTag<String> deviceInfoTag = new TupleTag<String>();
  final TupleTag<String> contactInfoTag = new TupleTag<String>();

  // transform both input collections to tuple collections, where the keys are country
  // codes in both cases.
  PCollection<KV<String, String>> deviceInfo = deviceTable.apply(
      ParDo.of(new CreateDeviceDataFn()));
  PCollection<KV<String, String>> contactInfo = contactTable.apply(
      ParDo.of(new CreateContactDataFn()));

  // country code 'key' -> CGBKR (<event info>, <country name>)
  PCollection<KV<String, CoGbkResult>> kvpCollection = KeyedPCollectionTuple
      .of(deviceInfoTag, deviceInfo)
      .and(contactInfoTag, contactInfo)
      .apply(CoGroupByKey.<String>create());

  // Process the CoGbkResult elements generated by the CoGroupByKey transform.
  // country code 'key' -> string of <event info>, <country name>
  PCollection<KV<String, String>> finalResultCollection =
    kvpCollection.apply("Process", ParDo.of(
      new DoFn<KV<String, CoGbkResult>, KV<String, String>>() {
        @ProcessElement
        public void processElement(ProcessContext c) {
          KV<String, CoGbkResult> e = c.element();
          String contact_seq = e.getKey();
          String contact = "none";
          contact = e.getValue().getOnly(contactInfoTag);
          for (String device : c.element().getValue().getAll(deviceInfoTag)) {
            // Generate a string that combines information from both collection values
            c.output(KV.of(device + "_" + contact_seq, contact ));
          }
        }
    }));

  // write to GCS
  PCollection<String> formattedResults = finalResultCollection
      .apply("Format", ParDo.of(new DoFn<KV<String, String>, String>() {
        @ProcessElement
        public void processElement(ProcessContext c) {
          String outputstring = c.element().getKey() + ", " + c.element().getValue();
          c.output(outputstring);
        }
      }));
  return formattedResults;
}


static class CreateDeviceDataFn extends DoFn<String, KV<String, String>> {
  @ProcessElement
  public void processElement(ProcessContext c) {
    String devicename = c.element();
    String seq; 

    for (int i = 1; i <= MAX_LINES; i++) {
          seq = String.valueOf(i);
          c.output(KV.of(seq, devicename));
    }

  }
}


static class CreateContactDataFn extends DoFn<String, KV<String, String>> {
  @ProcessElement
  public void processElement(ProcessContext c) {
    String line = c.element();

    c.output(KV.of(String.valueOf(sequence_key), line));
    sequence_key++;
  }
}


/**
 * Options supported by {@link JoinExamples}.
 *
 * <p>Inherits standard configuration options.
 */
private interface Options extends PipelineOptions {
  @Description("Path of the file to write to")
  @Validation.Required
  String getOutput();
  void setOutput(String value);
}

public static void main(String[] args) throws Exception {
  Options options = PipelineOptionsFactory.fromArgs(args).withValidation().as(Options.class);
  Pipeline p = Pipeline.create(options);


  PCollection<String> deviceTable =
       p.apply("ReadLines", TextIO.read().from(DEVICE_TABLE));

  PCollection<String> contactTable =
       p.apply("ReadLines", TextIO.read().from(CONTACT_TABLE));

/*
  PCollection<KV<String, String>> deviceInfo = deviceTable.apply(
      ParDo.of(new CreateDeviceDataFn()));
  PCollection<KV<String, String>> contactInfo = contactTable.apply(
      ParDo.of(new CreateContactDataFn()));

  PCollection<String> formattedResults = contactInfo
      .apply("Format", ParDo.of(new DoFn<KV<String, String>, String>() {
        @ProcessElement
        public void processElement(ProcessContext c) {
          String outputstring = c.element().getKey() + ", " + c.element().getValue();
          c.output(outputstring);
        }
      }));
*/

  PCollection<String> formattedResults = joinEvents(deviceTable, contactTable);

  formattedResults.apply(TextIO.write().to(options.getOutput()));

  p.run().waitUntilFinish();
}

}
